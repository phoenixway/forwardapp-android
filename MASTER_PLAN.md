# Новий Генеральний План: "Мікроядро та Інкрементне Відновлення"

Цей документ описує нову стратегію розробки, що базується на принципі "почни з малого". Ми видаляємо весь складний та потенційно проблемний код, залишаючи лише мінімально життєздатне "ядро" навколо сутності `Project`. Далі, крок за кроком, ми будемо відновлювати функціонал, адаптуючи старий код з Git-репозиторію та інтегруючи його в нову, чисту архітектуру.

## Філософія

1.  **Спочатку стабільність, потім функціонал:** Наша головна мета — завжди мати проєкт, що компілюється та запускається. Новий функціонал додається лише тоді, коли база стабільна.
2.  **`Project` — центр всесвіту:** Сутність `Project` є основою. Весь початковий код (UI, ViewModel, Data Layer) буде побудований навколо неї.
3.  **Інкрементне відновлення:** Замість великого "рефакторингу", ми будемо "відновлювати" фічі по одній, беручи за основу старий код, але адаптуючи його під KMP та чисту архітектуру.
4.  **Суворий контроль залежностей:** Кожна нова фіча додається з мінімальним і чітко визначеним набором залежностей. `RepositoryModule` та `DatabaseDriverFactory` будуть максимально спрощені.

---

## Фаза 1: Операція "Чистий Аркуш"

**Мета:** Радикально спростити проєкт, залишивши лише функціонал для перегляду списку проєктів.

- [ ] **1.1. Видалення всього зайвого (UI та ViewModel):**
    - [ ] Видалити всі UI-екрани (`*Screen.kt`), ViewModel-и (`*ViewModel.kt`) та навігаційні графіки, що не стосуються безпосередньо `Project`.
    - [ ] Залишити лише `ProjectScreen`, `ProjectViewModel` та головний `NavHost`, що показує тільки цей екран.

- [ ] **1.2. Видалення всього зайвого (Data Layer):**
    - [ ] Видалити всі репозиторії (`*Repository.kt`, `*RepositoryImpl.kt`), що не є `ProjectRepository` або його прямою залежністю.
    - [ ] Видалити всі `.sq` файли з `shared/src/commonMain/sqldelight/`, окрім `Projects.sq` та файлів, від яких він залежить.
    - [ ] Перемістити видалені `.sq` файли до папки `sqldelight_backup` для подальшого відновлення.

- [ ] **1.3. Очищення Dependency Injection:**
    - [ ] Спростити `RepositoryModule.kt` (`app/di`), залишивши лише `provideProjectRepository` та його мінімальні залежності.
    - [ ] Спростити `DatabaseDriverFactory.kt` (`shared/database`), видаливши всі `ColumnAdapter`, що не використовуються `Projects.sq`.

- [ ] **1.4. Створення мінімального ядра `Project`:**
    - [ ] **UI:** `ProjectScreen` має просто відображати список назв проєктів. Жодних дій (створення, редагування).
    - [ ] **ViewModel:** `ProjectViewModel` має містити лише `StateFlow<List<Project>>` та залежність від `ProjectRepository`.
    - [ ] **Data Layer:** `ProjectRepository` має працювати коректно, завантажуючи дані з `Projects.sq`.

- [ ] **1.5. Перевірка:**
    - [ ] Запустити команду `make debug-cycle` і переконатися, що проєкт компілюється, запускається і відображає список проєктів.

---

## Фаза 2: Інкрементне Відновлення Функціоналу

**Мета:** Поступово, фіча за фічею, повертати функціонал у проєкт, дотримуючись KMP-архітектури.

**Загальний процес для кожної фічі (наприклад, "Attachments"):**

- [ ] **2.1. Відновлення Data Layer:**
    - [ ] **Крок 1: SQLDelight:** Перемістити `Attachments.sq` з `sqldelight_backup` назад у `shared/src/commonMain/sqldelight/...`.
    - [ ] **Крок 2: Модель та Маппер:** Відновити з Git-історії доменну модель `Attachment.kt` та маппер для перетворення SQLDelight-сутності в доменну.
    - [ ] **Крок 3: Адаптери:** Якщо є кастомні типи, додати відповідні `ColumnAdapter` у `DatabaseDriverFactory.kt`.
    - [ ] **Крок 4: Репозиторій:** Відновити `AttachmentRepository` (інтерфейс у `commonMain`, реалізація в `androidMain`).
    - [ ] **Крок 5: DI:** Додати `provideAttachmentRepository` у `RepositoryModule.kt`.
    - [ ] **Крок 6: Перевірка:** Запустити `make debug-cycle` і переконатися, що проєкт компілюється.

- [ ] **2.2. Відновлення UI та Business Logic:**
    - [ ] **Крок 1: Shared ViewModel:** Створити `SharedAttachmentsViewModel` у `shared/.../features/attachments/ui/`, перенісши туди бізнес-логіку зі старої ViewModel.
    - [ ] **Крок 2: Android ViewModel:** Створити Android-обгортку `AttachmentsViewModel`, що делегує логіку до `SharedAttachmentsViewModel`.
    - [ ] **Крок 3: UI Screen:** Відновити з Git-історії `AttachmentsScreen.kt`.
    - [ ] **Крок 4: Адаптація:** Підключити `AttachmentsScreen` до нової ViewModel.
    - [ ] **Крок 5: Навігація:** Додати екран назад у навігаційний граф.
    - [ ] **Крок 6: Перевірка:** Запустити додаток і протестувати відновлений функціонал.

---

## План Відновлення Фіч (Пріоритетний список)

1.  **Projects (розширення):**
    - [ ] Додати можливість створення/редагування проєктів.
    - [ ] Відновити екран деталей проєкту.
2.  **Attachments:**
    - [ ] Відновити data layer, UI та ViewModel.
3.  **Notes (NoteDocument):**
    - [ ] Відновити data layer, UI та ViewModel.
4.  **Checklists:**
    - [ ] Відновити data layer, UI та ViewModel.
5.  **Recent Items:**
    - [ ] Відновити data layer та логіку.
6.  ... (решта фіч за пріоритетом)

---
## Фаза 3: Стабілізація Ініціалізації Бази Даних

**Мета:** Виправити та стабілізувати логіку `DatabaseInitializer`, щоб вона коректно обробляла будь-які стани системних проектів (відсутність, неправильне розміщення, змінені користувачем дані), не руйнуючи дані.

**Поточна Ситуація:**
Існуюча логіка в `DatabaseInitializer` є крихкою. Вона нездатна коректно обробити ситуації, коли ID системних проектів відрізняються від еталонних, що призводить до помилок у визначенні батьківських залежностей. Крім того, попередня спроба виправлення передбачала деструктивне видалення та перестворення проектів, що є неприпустимим, оскільки користувач може зберігати там свої дані або змінювати їхні імена.

**План дій:**

- [x] **3.1. Реалізувати неруйнівний алгоритм оновлення:**
    - [x] **Крок 1: Створити `idMap` для відстеження реальних ID.** В процесі ініціалізації буде створено тимчасову карту (`Map<String, String>`), що буде зберігати відповідність між еталонним ID проекту (з `specialProjects`) та його реальним ID в базі даних.
    - [x] **Крок 2: Знаходити проекти найнадійнішим способом.** Реалізувати функцію `findExistingProject`, яка шукає проекти за `ProjectType.SYSTEM`, `reservedGroup`, або в крайньому випадку за `id`.
    - [x] **Крок 3: Коректно визначати батьківський ID.** При обробці дочірнього проекту, ID його батька буде братися з `idMap`, а не з жорстко закодованого списку.
    - [x] **Крок 4: Виправляти лише розміщення.** Якщо проект існує, але його `parentId` неправильний, він буде виправлений через `updateParent`. **Ім'я та ID проекту не будуть змінюватися**, щоб зберегти дані користувача.
    - [x] **Крок 5: Створювати лише відсутні проекти.** Якщо проект не знайдено, він буде створений з використанням правильного батьківського ID з `idMap`.

- [x] **3.2. Валідація та Тестування:**
    - [x] Переконатися, що існуючі тести в `DatabaseInitializerTest` проходять з новою логікою.
    - [x] Додати нові тестові сценарії, що перевіряють стійкість до:
        - [x] Зміни ID системного проекту.
        - [x] Зміни імені системного проекту.
        - [x] Одночасної відсутності батьківського проекту та неправильного розміщення дочірнього.

Цей план є живою дорожньою картою. Пріоритети можуть змінюватися. Головне — рухатися невеликими, контрольованими кроками.