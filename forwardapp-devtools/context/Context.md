# CONTEXT.md
Документ оперативної пам'яті для агента розробки.
Використовується в кожній сесії.

---

## 1. Поточне завдання (CURRENT TASK)

- Провести аудит UI/UX коду продакшн-версії.
- Визначити, що можна покращити або виправити.

## 3. План дій
---

## 4. Невирішені проблеми / Блокери (PROBLEMS)
---

## 5. Значимі файли і модулі (IMPORTANT FILES / MODULES)
---

## 6. Інструкції та вимоги до стилю (INSTRUCTIONS)

- Не переписувати архітектуру без підтвердження  
- Виконувати лише один крок за раз  
- Не змінювати DI без дозволу  
- Додавати пропозицію оновлення контексту після кожної дії  
- Писати код, що точно компілюється  
- Завжди пояснювати причину помилки  

---

## 7. Замітки для агента (NOTES)

**Резюме аудиту UI/UX:**

**Проблеми високого пріоритету:**
1.  **Перевантажена та нестандартна нижня навігація:** Компонент `ExpandingBottomNav` приховує ключові функції та використовує складні, не інтуїтивні патерни ("меню в меню"). Це є значним ризиком для юзабіліті.
2.  **Нестандартна взаємодія з FAB:** Кнопка FAB має дві різні дії (натискання та утримання), що плутає користувача і є непередбачуваним.
3.  **Агресивний Edge-to-Edge:** Приховування системної навігаційної панелі за замовчуванням порушує стандартну поведінку Android і може дезорієнтувати користувачів.

**Проблеми середнього пріоритету:**
1.  **Автентифікація через WebView:** Створює неконсистентний та повільний досвід порівняно з нативним екраном.
2.  **Процес запиту дозволів:** Діалоги дозволів перевантажують користувача, не локалізовані та мають візуальні дефекти (іконки).
3.  **Кастомна логіка кнопки "Назад":** Схильна до помилок, які можуть призвести до непередбачуваної поведінки та заплутати користувача.

**Рекомендації:**
- **Замінити `ExpandingBottomNav`** на стандартний Material 3 `NavigationBar`.
- **Спростити FAB** до однієї дії при натисканні.
- **Відкоригувати Edge-to-Edge,** залишивши системну навігацію видимою.
- **Створити нативний екран** для автентифікації.
- **Покращити потік запиту дозволів,** зробивши його контекстуальним та візуально чистим.

- обов'язково перечитай весь вміст папки docs

---

## 8. Після цього
- зроби огляд коду прод частини щодо ui ux. що упущено, що треба покращити. що має неприйнятний рівень для додатка якому робиться реліз


• Щоб експериментальний код не потрапляв у прод, але був у окремому “exp prod” і в debug, найчистіше розвести це на рівні збірок і сорс-
  сетів:

  1. Build variants/flavors:
      - Введи productFlavors, напр. prod і exp. Debug залишається як buildType.
      - Створи окремий сорс-сет app/src/exp (і за потреби expDebug, expRelease) для експериментального коду/UI. У prod цих файлів немає.
      - Для кодових шляхів, які мають різні реалізації, використовуй інтерфейси + реалізації в src/prod vs src/exp.
      - В AndroidManifest окремі налаштування/пермішени теж можна розводити по flavor'ах.
  2. Gradle-константи:
      - Додай BuildConfig.IS_EXPERIMENTAL = true/false на рівні flavor; у прод — false, в exp/debug — true.
      - В експериментальних фіча-флагах використовуй це як “kill-switch”: не ініціалізуй/не реєструй граф/екрани, якщо флаг false.
  3. Фічі як модулі:
      - Винеси експериментальні частини в окремий module (lib), додавай залежність лише в expImplementation й debugImplementation, але не
        в prodImplementation.
  4. Ресурси/шари:
      - Якщо є UI-різниці, ресурси можна покласти в src/exp/res і src/prod/res. Для відсутніх у прод екранів просто не додавай маршрут/
        навігацію в прод-версії.
  5. Збірка:
      - Основний стор вивантажуєш prodRelease (без експериментів).
      - “Експериментальний прод” — збірка expRelease (той самий підпис, інший applicationIdSuffix, або internal track).
  6. Деплой/треки:
      - У Play Console: prodRelease → production, expRelease → internal/alpha/beta або окремий appId для інтерних користувачів.

  Так ти фізично відріжеш код із прод-артефакту, а експериментальне — тільки у exp і debug.


› як винести в модуль той же ai chat - він же сильно інтегрований?


• Для важкої інтеграції (як AI Chat) повне винесення в модуль можна робити поетапно:

  1. Введи чіткий API/інтерфейси:
      - Створи інтерфейс на рівні “AiChatFeature” (методи для навігації, UI entrypoints, настройки Ollama/ролей/моделей).
      - В основному модулі споживай тільки цей інтерфейс; не тягни прямі залежності на AiChat екрани/VM.
  2. Спліт на окремий module:
      - Створи :feature:aichat (android library).
      - Перенеси UI (ChatScreen/ViewModel), репозиторії чатів/ролей, Ollama клієнт у цей модуль.
      - В модулі експортуй навігаційний провайдер/компонент, який реєструє маршрути або віддає Composable entrypoint.
  3. Депенденсі у flavors:
      - У головному module app в build.gradle підключи:
          - debugImplementation project(":feature:aichat")
          - expImplementation project(":feature:aichat") (якщо є exp flavor)
          - Не підключай у prodImplementation.
      - Тоді прод-артефакт не матиме класів AI Chat.
  4. Навігація умовна:
      - У prod реалізація AiChatFeature = заглушка (повертає “feature disabled”), не реєструє маршрутів.
      - У exp/debug реальна реалізація із модулю :feature:aichat.
      - В existing навігації перевіряй AiChatFeature.isAvailable або BuildConfig/флаг, щоб не додавати маршрути в прод.
  5. DI/компіляція:
      - Винеси Hilt-модулі (OllamaService, репозиторії) у :feature:aichat.
      - У prod конфіг/gradle не включай цей модуль → немає бінів → не буде wiring.
  6. Ресурси/маніфест:
      - В :feature:aichat власні ресурси/пермішени. Якщо є спеціальні пермішени (наприклад, мережеві), переконайся, що вони не додаються
        в prod.

  Якщо повне винесення зараз занадто важке, мінімальний крок — зробити окремі entrypoints через інтерфейс + flavor-залежності (реальна
  реалізація в debug/exp, заглушка в prod) і не реєструвати екрани в prod. Це вже прибере AI Chat із прод-збірки.
--- 

