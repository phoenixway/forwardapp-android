Поточна архітектура drag-and-drop (dnd) має декілька недоліків:

1.  **Надмірна складність і зв'язаність:** `DragDropManager` напряму залежить від `LazyListState`, що ускладнює його тестування. Логіка розкидана між `DragDropManager`, `ProjectScreenViewModel` та `InteractiveListItem`.
2.  **Низька тестопридатність:** Через жорстку прив'язку до Android-компонентів ( `LazyListState`), написання Unit-тестів для критичної логіки (`calculateTargetIndex`, розрахунок зміщень) є практично неможливим.
3.  **Неявні залежності:** Логіка в `InteractiveListItem` для розрахунку зміщення `yOffset` робить компонент менш передбачуваним.

Я пропоную провести рефакторинг, щоб привести архітектуру у відповідність до принципів чистої архітектури та зробити її повністю тестопридатною.

### План рефакторингу

1.  **Створити чіткий контракт для `LazyListState`:**
    *   Відновити інтерфейс `LazyListInfoProvider`, який буде абстрагувати `LazyListState` і надаватиме лише необхідну інформацію (`visibleItemsInfo`, `firstVisibleItemScrollOffset` і т.д.).
    *   `DragDropManager` буде залежати від цього інтерфейсу, а не від конкретної реалізації.

2.  **Централізувати логіку в `DragDropManager`:**
    *   Перенести всю логіку розрахунку зміщень (включаючи `getItemOffset` з `InteractiveListItem`) до `DragDropManager`.
    *   `DragDropManager` буде оновлювати єдиний об'єкт стану `DragState`, який міститиме всю інформацію про поточну операцію dnd, включаючи зміщення для кожного елемента.

3.  **Спростити Composable-компоненти:**
    *   `InteractiveListItem` та інші компоненти будуть лише відображати стан, що надходить з `ViewModel`, і не міститимуть жодної бізнес-логіки.

4.  **Написати Unit-тести:**
    *   Після рефакторингу я зможу написати вичерпні тести для `DragDropManager`, перевіряючи всю критичну логіку в ізоляції від UI.

Цей рефакторинг зробить код чистішим, надійнішим і дозволить легко додавати нову функціональність у майбутньому. Якщо ви згодні, я додам це до нашого `MASTER_PLAN.md`.