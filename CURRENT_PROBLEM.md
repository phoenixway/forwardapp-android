Поточна проблема: Відсутність візуальних ефектів перетягування (Drag-and-Drop).

Незважаючи на те, що логічний стан DnD (`DragAndDropState`) та візуальний стан (`DnDVisualState`) обчислюються коректно (згідно з логами `InteractiveListItem` та `DraggableItem`), візуальні ефекти перетягування (зміщення, тінь, прозорість) не відображаються на екрані.

**Деталі проблеми:**

*   Логи показують, що `isDraggingThisItem` та `yOffset` для перетягуваного елемента мають правильні значення (`true` та ненульове зміщення).
*   `DraggableItem` отримує ці значення і застосовує `graphicsLayer` з відповідними `translationY`, `scaleX`, `scaleY`, `alpha` та `shadowElevation`.
*   Проте, на екрані елемент не змінює свого вигляду під час перетягування.

**Можливі причини:**

1.  **Конфлікт модифікаторів у `SwipeableListItem`:** `SwipeableListItem` застосовує власні `shadow` та `graphicsLayer` (для `rotationZ`), а також `offset` для свайп-жестів. Ці модифікатори можуть перекривати або конфліктувати з візуальними ефектами, що застосовуються `DraggableItem`.
2.  **Проблема з `zIndex`:** Хоча `DraggableItem` встановлює `zIndex` для перетягуваного елемента, можливо, інші елементи або батьківські контейнери мають вищий `zIndex` або неправильно обробляють його, перекриваючи перетягуваний елемент.
3.  **Неправильне застосування `Modifier.height`:** Модифікатор `height` для резервування місця застосовується до `DraggableItem` через `modifier.then(...)`. Можливо, це впливає на те, як `graphicsLayer` відображається.
4.  **Проблема з перекомпозицією:** Хоча `StateFlow` використовується для оновлення стану, можливо, є нюанси в перекомпозиції, які не дозволяють UI оновлюватися візуально.

**Наступні кроки:**

1.  **Видалити логування:** Прибрати додане логування з `InteractiveListItem.kt` та `DraggableItem.kt`.
2.  **Спростити `InteractiveListItem` та `DraggableItem`:**
    *   Переконатися, що `DraggableItem` є єдиним місцем, де застосовуються `graphicsLayer` для `translationY`, `scale`, `alpha` та `shadowElevation`.
    *   Модифікувати `SwipeableListItem`, щоб він не застосовував жодних `graphicsLayer` або `shadow` модифікаторів, які можуть конфліктувати з `DraggableItem` під час перетягування.
    *   Перевірити, як `Modifier.height` застосовується для резервування місця. Можливо, його потрібно застосовувати до батьківського контейнера `DraggableItem`, а не до самого `DraggableItem`.
3.  **Перевірити `zIndex`:** Переконатися, що `zIndex` коректно працює і перетягуваний елемент завжди знаходиться поверх інших.
4.  **Ізольоване тестування візуальних ефектів:** Створити мінімальний приклад з `DraggableItem` та `SwipeableListItem` без складної логіки DnD, щоб перевірити лише візуальні ефекти.