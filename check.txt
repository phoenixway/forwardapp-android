Дякую за детальний аналіз! Ви абсолютно праві — проблема в тому, що **LazyColumn не призначений для ручного керування позицією елементів через `translationY`**. Це порушує його внутрішню систему віртуалізації та layout.

## Правильне рішення: Ghost Element Pattern

Я реалізую архітектуру, де:
1. **Оригінальний елемент стає невидимим** під час драгу
2. **"Примарний" елемент** рендериться поверх екрана
3. **LazyColumn природно анімує** решту через `Modifier.animateItem()`## Ключові зміни в архітектурі

### 1. **DragAndDropState** тепер зберігає `ghostScreenY`
```kotlin
val ghostScreenY: Float = 0f  // Абсолютна Y позиція на екрані
```
Це **проста координата** для позиціонування ghost елемента, без складних обчислень.

### 2. **InteractiveListItem** став простим
```kotlin
val itemModifier = if (isDraggingThisItem) {
    modifier.graphicsLayer { alpha = 0f }  // Невидимий
} else {
    modifier.animateItem()  // Природна анімація LazyColumn
}
```
- Елемент, що перетягується, **невидимий** (але займає місце)
- Інші елементи використовують **стандартну анімацію** LazyColumn

### 3. **BacklogView** рендерить Ghost Element
```kotlin
if (dragState.dragInProgress && dragState.draggedItemIndex != null) {
    Box(
        modifier = Modifier
            .offset { IntOffset(0, dragState.ghostScreenY.roundToInt()) }
            .zIndex(999f)
            .graphicsLayer { alpha = 0.9f; shadowElevation = 16f }
    ) {
        // Рендеримо копію елемента
    }
}
```

### 4. **DragHandleModifier** оновлено
Потрібно передавати `itemHeight` при старті:

```kotlin
fun Modifier.dragHandle(
    dragDropManager: DragDropManager,
    itemIndex: Int,
    lazyListState: LazyListState,
    scope: CoroutineScope,
    onDragStateChanged: (Boolean) -> Unit
): Modifier = this.pointerInput(itemIndex) {
    awaitEachGesture {
        val down = awaitFirstDown(requireUnconsumed = false, pass = PointerEventPass.Initial)
        onDragStateChanged(true)
        
        var totalDrag = Offset.Zero
        var dragStarted = false
        val dragThreshold = 15f
        
        try {
            val dragResult = drag(down.id) { change ->
                totalDrag += change.positionChange()
                
                if (!dragStarted && totalDrag.getDistance() > dragThreshold) {
                    dragStarted = true
                    
                    val itemInfo = lazyListState.layoutInfo.visibleItemsInfo
                        .firstOrNull { it.index == itemIndex }
                    
                    if (itemInfo != null) {
                        val initialItemOffset = itemInfo.offset
                        val dragOffsetInItem = change.position.y - initialItemOffset
                        val itemHeight = itemInfo.size.toFloat()  // ✅
                        
                        dragDropManager.onDragStart(
                            offset = change.position,
                            index = itemInfo.index,
                            initialItemOffset = initialItemOffset,
                            dragOffsetInItem = dragOffsetInItem,
                            itemHeight = itemHeight  // ✅
                        )
                    }
                }
                
                if (dragStarted) {
                    change.consume()
                    dragDropManager.onDrag(change.position)
                }
            }
            
            if (dragStarted) {
                dragDropManager.onDragEnd()
            }
        } finally {
            onDragStateChanged(false)
        }
    }
}
```

## Оновлення ViewModel

У `BacklogViewModel.kt` змініть ініціалізацію:

```kotlin
init {
    // ...
    dndVisualsManager = DnDVisualsManager(lazyListInfoProvider, dragDropManager)
    
    // ✅ Оновлюємо targetIndex при кожному русі
    viewModelScope.launch {
        dragState.collect { state ->
            if (state.dragInProgress) {
                dndVisualsManager.calculateTargetIndex(state)
            }
        }
    }
}
```

## Чому це працює

1. **LazyColumn контролює свої елементи** — ми не втручаємося в його layout
2. **Ghost елемент незалежний** — рендериться в `Box` на верхньому рівні
3. **`animateItem()`** природно анімує перестановку елементів
4. **Немає конфліктів** з `anchoredDraggable`, тому що ми не чіпаємо `translationY` реальних елементів

## Результат

- ✅ Плавне перетягування без артефактів
- ✅ Елементи природно розсуваються
- ✅ Ghost елемент рухається за пальцем
- ✅ Свайп продовжує працювати на інших елементах

***

// ============================================================================
// 1. DragAndDropState.kt - Оновлений стан
// ============================================================================
package com.romankozak.forwardappmobile.ui.dnd

import androidx.compose.ui.geometry.Offset

data class DragAndDropState(
    val dragInProgress: Boolean = false,
    val draggedItemIndex: Int? = null,
    val targetItemIndex: Int? = null,
    val dragAmount: Offset = Offset.Zero,
    val initialItemOffset: Int = 0,
    val dragOffsetInItem: Float = 0f,
    // ✅ НОВЕ: Дані для рендерингу ghost елемента
    val draggedItemHeight: Float = 0f,
    val ghostScreenY: Float = 0f  // Абсолютна Y позиція на екрані
)

// ============================================================================
// 2. DragDropManager.kt - Оновлений менеджер
// ============================================================================
package com.romankozak.forwardappmobile.ui.dnd

import androidx.compose.ui.geometry.Offset
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

class DragDropManager(
    private val scope: CoroutineScope,
    private val onMove: (Int, Int) -> Unit,
    private val scrollBy: suspend (Float) -> Unit
) {
    private val _dragState = MutableStateFlow(DragAndDropState())
    val dragState: StateFlow<DragAndDropState> = _dragState.asStateFlow()

    private var autoScrollJob: Job? = null

    fun onDragStart(
        offset: Offset, 
        index: Int, 
        initialItemOffset: Int, 
        dragOffsetInItem: Float,
        itemHeight: Float  // ✅ НОВЕ
    ) {
        _dragState.update {
            it.copy(
                dragInProgress = true,
                draggedItemIndex = index,
                dragAmount = offset,
                initialItemOffset = initialItemOffset,
                dragOffsetInItem = dragOffsetInItem,
                draggedItemHeight = itemHeight,  // ✅
                ghostScreenY = offset.y - dragOffsetInItem  // ✅
            )
        }

        autoScrollJob?.cancel()
        autoScrollJob = scope.launch {
            while (true) {
                delay(16)
                val fingerY = _dragState.value.dragAmount.y
                val viewportHeight = 2000f
                val hotZone = viewportHeight * 0.2f

                val scrollAmount = when {
                    fingerY < hotZone -> {
                        val distance = hotZone - fingerY
                        -(distance / hotZone) * 100f
                    }
                    fingerY > viewportHeight - hotZone -> {
                        val distance = fingerY - (viewportHeight - hotZone)
                        (distance / hotZone) * 100f
                    }
                    else -> 0f
                }

                if (scrollAmount != 0f) {
                    scope.launch { scrollBy(scrollAmount) }
                }
            }
        }
    }

    fun onDrag(position: Offset) {
        _dragState.update { 
            it.copy(
                dragAmount = position,
                ghostScreenY = position.y - it.dragOffsetInItem  // ✅ Оновлюємо позицію ghost
            )
        }
    }

    fun onDragEnd() {
        autoScrollJob?.cancel()
        val draggedItemIndex = _dragState.value.draggedItemIndex
        val targetItemIndex = _dragState.value.targetItemIndex

        if (draggedItemIndex != null && targetItemIndex != null && draggedItemIndex != targetItemIndex) {
            onMove(draggedItemIndex, targetItemIndex)
        }

        _dragState.update {
            it.copy(
                dragInProgress = false,
                draggedItemIndex = null,
                targetItemIndex = null,
                dragAmount = Offset.Zero
            )
        }
    }

    fun setTargetItemIndex(index: Int?) {
        _dragState.update { it.copy(targetItemIndex = index) }
    }
}

// ============================================================================
// 3. DnDVisualsManager.kt - СПРОЩЕНИЙ (без itemOffsets)
// ============================================================================
package com.romankozak.forwardappmobile.ui.dnd

import android.util.Log

private const val TAG = "DnDVisualsManager"

class DnDVisualsManager(
    private val lazyListInfoProvider: LazyListInfoProvider,
    private val dragDropManager: DragDropManager
) {
    fun calculateTargetIndex(dragAndDropState: DragAndDropState) {
        val draggedItemIndex = dragAndDropState.draggedItemIndex
        val dragAmount = dragAndDropState.dragAmount

        if (!dragAndDropState.dragInProgress || draggedItemIndex == null) return

        // ✅ Знаходимо індекс, над яким знаходиться палець
        val newTargetIndex = lazyListInfoProvider.lazyListItemInfo
            .firstOrNull { item ->
                val itemTop = item.offset
                val itemBottom = item.offset + item.size
                val fingerY = dragAmount.y
                fingerY > itemTop && fingerY < itemBottom && item.index != draggedItemIndex
            }?.index

        if (newTargetIndex != dragAndDropState.targetItemIndex) {
            Log.d(TAG, "Target changed: ${dragAndDropState.targetItemIndex} -> $newTargetIndex")
            dragDropManager.setTargetItemIndex(newTargetIndex)
        }
    }
}

// ============================================================================
// 4. InteractiveListItem.kt - СПРОЩЕНИЙ (без yOffset)
// ============================================================================
package com.romankozak.forwardappmobile.ui.screens.projectscreen.components.dnd

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.spring
import androidx.compose.material3.MaterialTheme
import androidx.compose.ui.graphics.graphicsLayer
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import kotlinx.coroutines.flow.StateFlow
import com.romankozak.forwardappmobile.ui.dnd.DragAndDropState
import com.romankozak.forwardappmobile.data.database.models.ListItemContent
import com.romankozak.forwardappmobile.ui.screens.projectscreen.components.backlogitems.SwipeableListItem

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun InteractiveListItem(
    item: ListItemContent,
    index: Int,
    dragAndDropState: DragAndDropState,
    listState: androidx.compose.foundation.lazy.LazyListState,
    isSelected: Boolean,
    isHighlighted: Boolean,
    swipeEnabled: Boolean,
    isAnotherItemSwiped: Boolean,
    resetTrigger: Int,
    onSwipeStart: () -> Unit,
    onDelete: () -> Unit,
    onMoreActionsRequest: () -> Unit,
    onMoveToTopRequest: () -> Unit,
    onStartTrackingRequest: () -> Unit,
    onAddToDayPlanRequest: () -> Unit,
    onShowGoalTransportMenu: (ListItemContent) -> Unit,
    onCopyContentRequest: () -> Unit,
    onToggleCompleted: () -> Unit,
    modifier: Modifier = Modifier,
    content: @Composable (isDragging: Boolean) -> Unit,
) {
    val isCompleted = when (item) {
        is ListItemContent.GoalItem -> item.goal.completed
        is ListItemContent.SublistItem -> item.project.isCompleted
        else -> false
    }

    val backgroundColor by animateColorAsState(
        targetValue = when {
            isHighlighted -> MaterialTheme.colorScheme.tertiaryContainer
            isSelected -> MaterialTheme.colorScheme.primaryContainer
            isCompleted -> MaterialTheme.colorScheme.surfaceVariant
            else -> MaterialTheme.colorScheme.surface
        },
        animationSpec = spring(),
        label = "interactive_item_background",
    )

    val isDraggingThisItem = dragAndDropState.dragInProgress && dragAndDropState.draggedItemIndex == index

    // ✅ КЛЮЧОВЕ ВИПРАВЛЕННЯ: Елемент стає невидимим під час драгу
    val itemModifier = if (isDraggingThisItem) {
        modifier.graphicsLayer { alpha = 0f }  // Невидимий, але займає місце
    } else {
        modifier.animateItem()  // Природна анімація LazyColumn
    }

    SwipeableListItem(
        modifier = itemModifier,
        isDragging = isDraggingThisItem,
        isAnyItemDragging = dragAndDropState.dragInProgress,
        swipeEnabled = swipeEnabled,
        isAnotherItemSwiped = isAnotherItemSwiped,
        resetTrigger = resetTrigger,
        onSwipeStart = onSwipeStart,
        onDelete = onDelete,
        onMoreActionsRequest = onMoreActionsRequest,
        onMoveToTopRequest = onMoveToTopRequest,
        onGoalTransportRequest = { onShowGoalTransportMenu(item) },
        onStartTrackingRequest = onStartTrackingRequest,
        onAddToDayPlanRequest = onAddToDayPlanRequest,
        onCopyContentRequest = onCopyContentRequest,
        onToggleCompleted = onToggleCompleted,
        backgroundColor = backgroundColor,
        content = {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
            ) {
                Box(modifier = Modifier.weight(1f)) {
                    content(isDraggingThisItem)
                }
            }
        },
    )
}

// ============================================================================
// 5. BacklogView.kt - З Ghost Element Overlay
// ============================================================================
package com.romankozak.forwardappmobile.ui.screens.projectscreen.views

import android.util.Log
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyListState
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.zIndex
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.romankozak.forwardappmobile.data.database.models.ListItemContent
import com.romankozak.forwardappmobile.ui.dnd.dragHandle
import com.romankozak.forwardappmobile.ui.screens.projectscreen.BacklogViewModel
import com.romankozak.forwardappmobile.ui.screens.projectscreen.UiState
import com.romankozak.forwardappmobile.ui.screens.projectscreen.components.attachments.AttachmentsSection
import com.romankozak.forwardappmobile.ui.screens.projectscreen.components.backlogitems.GoalItem
import com.romankozak.forwardappmobile.ui.screens.projectscreen.components.backlogitems.SubprojectItemRow
import com.romankozak.forwardappmobile.ui.screens.projectscreen.components.dnd.InteractiveListItem
import com.romankozak.forwardappmobile.ui.screens.projectscreen.components.dnd.MoreActionsButton
import kotlinx.coroutines.flow.StateFlow
import kotlin.math.roundToInt

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun BacklogView(
    modifier: Modifier = Modifier,
    viewModel: BacklogViewModel,
    uiState: UiState,
    listState: LazyListState,
    listContent: List<ListItemContent>,
    isAttachmentsExpanded: Boolean,
    swipeEnabled: Boolean,
    dragDropManager: com.romankozak.forwardappmobile.ui.dnd.DragDropManager,
) {
    val obsidianVaultName by viewModel.obsidianVaultName.collectAsStateWithLifecycle()
    val contextMarkerToEmojiMap by viewModel.contextMarkerToEmojiMap.collectAsStateWithLifecycle()
    val currentListContextEmojiToHide by viewModel.currentProjectContextEmojiToHide.collectAsStateWithLifecycle()
    val subprojectChildren by viewModel.subprojectChildren.collectAsStateWithLifecycle()
    val dragState by viewModel.dragState.collectAsState()
    
    var isAnyDragHandleActive by remember { mutableStateOf(false) }

    LaunchedEffect(listState) {
        viewModel.setLazyListState(listState)
    }

    LaunchedEffect(viewModel.uiEventFlow) {
        viewModel.uiEventFlow.collect { event ->
            when (event) {
                is com.romankozak.forwardappmobile.ui.screens.projectscreen.UiEvent.ScrollTo -> {
                    listState.animateScrollToItem(event.index)
                }
                else -> {}
            }
        }
    }

    // ✅ Оновлюємо targetIndex при русі
    LaunchedEffect(dragState.dragAmount) {
        if (dragState.dragInProgress) {
            viewModel.dndVisualsManager.calculateTargetIndex(dragState)
        }
    }

    val attachmentItems = remember(listContent) {
        listContent.filter { 
            it is ListItemContent.LinkItem || 
            it is ListItemContent.NoteItem || 
            it is ListItemContent.CustomListItem 
        }
    }
    val draggableItems = remember(listContent) {
        listContent.filterNot { 
            it is ListItemContent.LinkItem || 
            it is ListItemContent.NoteItem || 
            it is ListItemContent.CustomListItem 
        }
    }

    val scope = rememberCoroutineScope()

    Box(modifier = modifier.fillMaxSize()) {
        Column(modifier = Modifier.fillMaxSize()) {
            AttachmentsSection(
                attachments = attachmentItems,
                isExpanded = isAttachmentsExpanded,
                onAddAttachment = { viewModel.onAddAttachment(it) },
                onDeleteItem = { viewModel.itemActionHandler.deleteItem(it) },
                onItemClick = { viewModel.itemActionHandler.onItemClick(it) },
                onCopyContentRequest = { viewModel.itemActionHandler.copyContentRequest(it) },
            )

            LazyColumn(
                state = listState,
                modifier = Modifier.fillMaxWidth().weight(1f),
                userScrollEnabled = !isAnyDragHandleActive
            ) {
                itemsIndexed(
                    items = draggableItems,
                    key = { _, item -> item.listItem.id },
                ) { index, content ->
                    val isSelected = content.listItem.id in uiState.selectedItemIds
                    val isHighlighted = (uiState.itemToHighlight == content.listItem.id) ||
                        (content is ListItemContent.GoalItem && content.goal.id == uiState.goalToHighlight)

                    InteractiveListItem(
                        item = content,
                        index = index,
                        dragAndDropState = dragState,
                        listState = listState,
                        isSelected = isSelected,
                        isHighlighted = isHighlighted,
                        swipeEnabled = swipeEnabled && !isAnyDragHandleActive,
                        isAnotherItemSwiped = (uiState.swipedItemId != null) && (uiState.swipedItemId != content.listItem.id),
                        resetTrigger = uiState.resetTriggers[content.listItem.id] ?: 0,
                        onSwipeStart = { viewModel.onSwipeStart(content.listItem.id) },
                        onDelete = { viewModel.itemActionHandler.deleteItem(content) },
                        onMoreActionsRequest = { viewModel.itemActionHandler.onGoalActionInitiated(content) },
                        onMoveToTopRequest = { viewModel.onMoveToTop(content) },
                        onAddToDayPlanRequest = { viewModel.addItemToDailyPlan(content) },
                        onShowGoalTransportMenu = { itemToTransport ->
                            viewModel.itemActionHandler.onGoalTransportInitiated(
                                itemToTransport,
                                onCopyContentToClipboard = {
                                    viewModel.itemActionHandler.copyContentRequest(itemToTransport)
                                },
                            )
                        },
                        onStartTrackingRequest = { viewModel.onStartTrackingRequest(content) },
                        onCopyContentRequest = { viewModel.itemActionHandler.copyContentRequest(content) },
                        onToggleCompleted = {
                            when (content) {
                                is ListItemContent.GoalItem -> {
                                    viewModel.itemActionHandler.toggleGoalCompletedWithState(content.goal, !content.goal.completed)
                                }
                                is ListItemContent.SublistItem -> {
                                    viewModel.onSubprojectCompletedChanged(content.project, !content.project.isCompleted)
                                }
                                else -> {}
                            }
                        },
                        modifier = Modifier
                    ) { isDragging ->
                        when (content) {
                            is ListItemContent.GoalItem -> {
                                GoalItem(
                                    goal = content.goal,
                                    reminders = content.reminders,
                                    obsidianVaultName = obsidianVaultName,
                                    showCheckbox = uiState.showCheckboxes,
                                    onCheckedChange = { isChecked ->
                                        viewModel.itemActionHandler.toggleGoalCompletedWithState(
                                            content.goal,
                                            isChecked,
                                        )
                                    },
                                    onItemClick = { viewModel.itemActionHandler.onItemClick(content) },
                                    onLongClick = { viewModel.toggleSelection(content.listItem.id) },
                                    onTagClick = { tag -> viewModel.onTagClicked(tag) },
                                    onRelatedLinkClick = { link -> viewModel.onLinkItemClick(link) },
                                    contextMarkerToEmojiMap = contextMarkerToEmojiMap,
                                    emojiToHide = currentListContextEmojiToHide,
                                    isSelected = isSelected,
                                    endAction = {
                                        MoreActionsButton(
                                            isDragging = isDragging,
                                            onMoreClick = { viewModel.itemActionHandler.onGoalActionInitiated(content) },
                                            dragHandleModifier = Modifier.dragHandle(
                                                dragDropManager = dragDropManager,
                                                itemIndex = index,
                                                lazyListState = listState,
                                                scope = scope,
                                                onDragStateChanged = { isAnyDragHandleActive = it }
                                            )
                                        )
                                    }
                                )
                            }
                            is ListItemContent.SublistItem -> {
                                val children = subprojectChildren[content.project.id] ?: emptyList()
                                SubprojectItemRow(
                                    subprojectContent = content,
                                    reminders = content.reminders,
                                    isSelected = isSelected,
                                    showCheckbox = uiState.showCheckboxes,
                                    onClick = { viewModel.itemActionHandler.onItemClick(content) },
                                    onLongClick = { viewModel.toggleSelection(content.listItem.id) },
                                    onCheckedChange = { isCompleted ->
                                        viewModel.onSubprojectCompletedChanged(content.project, isCompleted)
                                    },
                                    childProjects = children,
                                    onChildProjectClick = { child -> viewModel.onChildProjectClick(child) },
                                    contextMarkerToEmojiMap = contextMarkerToEmojiMap,
                                    emojiToHide = currentListContextEmojiToHide,
                                    endAction = {
                                        MoreActionsButton(
                                            isDragging = isDragging,
                                            onMoreClick = { viewModel.itemActionHandler.onGoalActionInitiated(content) },
                                            dragHandleModifier = Modifier.dragHandle(
                                                dragDropManager = dragDropManager,
                                                itemIndex = index,
                                                lazyListState = listState,
                                                scope = scope,
                                                onDragStateChanged = { isAnyDragHandleActive = it }
                                            )
                                        )
                                    }
                                )
                            }
                            else -> {
                                Log.w("BacklogScreen", "Unsupported type: ${content::class.simpleName}")
                            }
                        }
                    }
                }
            }
        }

        // ✅ GHOST ELEMENT - рендериться поверх всього
        if (dragState.dragInProgress && dragState.draggedItemIndex != null) {
            val draggedItem = draggableItems.getOrNull(dragState.draggedItemIndex)
            if (draggedItem != null) {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .offset { IntOffset(0, dragState.ghostScreenY.roundToInt()) }
                        .zIndex(999f)  // Поверх всього
                        .graphicsLayer {
                            alpha = 0.9f
                            shadowElevation = 16f
                        }
                ) {
                    // Рендеримо той самий контент
                    when (draggedItem) {
                        is ListItemContent.GoalItem -> {
                            GoalItem(
                                goal = draggedItem.goal,
                                reminders = draggedItem.reminders,
                                obsidianVaultName = obsidianVaultName,
                                showCheckbox = uiState.showCheckboxes,
                                onCheckedChange = {},
                                onItemClick = {},
                                onLongClick = {},
                                onTagClick = {},
                                onRelatedLinkClick = {},
                                contextMarkerToEmojiMap = contextMarkerToEmojiMap,
                                emojiToHide = currentListContextEmojiToHide,
                                isSelected = false,
                                endAction = {
                                    MoreActionsButton(
                                        isDragging = true,
                                        onMoreClick = {},
                                        dragHandleModifier = Modifier
                                    )
                                }
                            )
                        }
                        is ListItemContent.SublistItem -> {
                            val children = subprojectChildren[draggedItem.project.id] ?: emptyList()
                            SubprojectItemRow(
                                subprojectContent = draggedItem,
                                reminders = draggedItem.reminders,
                                isSelected = false,
                                showCheckbox = uiState.showCheckboxes,
                                onClick = {},
                                onLongClick = {},
                                onCheckedChange = {},
                                childProjects = children,
                                onChildProjectClick = {},
                                contextMarkerToEmojiMap = contextMarkerToEmojiMap,
                                emojiToHide = currentListContextEmojiToHide,
                                endAction = {
                                    MoreActionsButton(
                                        isDragging = true,
                                        onMoreClick = {},
                                        dragHandleModifier = Modifier
                                    )
                                }
                            )
                        }
                        else -> {}
                    }
                }
            }
        }
    }
}

***


