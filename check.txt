Аналізуючи логи, я бачу **справжню проблему**: offset обчислюється правильно, але елемент **стрибає** між великими та малими значеннями. Це класична ознака того, що `initialItemOffset` розраховується **один раз** при старті драгу, але потім **елемент змінює свою позицію в LazyColumn** через реорганізацію, і старий offset стає некоректним.

## Ключова проблема

Подивіться на ці логи:
```
Offset: 446.9344 | dragAmount.y=570.4969, initialItemOffset=313
Offset: 31.862946 | dragAmount.y=155.42545, initialItemOffset=313  // ❌ Стрибок!
Offset: 441.4781 | dragAmount.y=565.0406, initialItemOffset=313
```

Елемент **стрибає** між різними позиціями, тому що:
1. `initialItemOffset=313` зберігається на початку драгу
2. Але коли ви перетягуєте елемент вниз, LazyColumn **перекомпозує** і елемент тепер на іншій позиції
3. Формула `dragAmount.y - initialItemOffset - dragOffsetInItem` використовує **застарілі** дані

## Рішення

Потрібно **динамічно оновлювати** `initialItemOffset` під час драгу:## Що змінилося

### До (проблемна версія):
```kotlin
val calculatedOffset = dragAmount.y - dragAndDropState.initialItemOffset - dragAndDropState.dragOffsetInItem
```
Використовувалося **збережене** значення `initialItemOffset` (313px у ваших логах), яке **ніколи не оновлювалося**.

### Після (виправлена версія):
```kotlin
val currentItemOffset = draggedItemInfo.offset.toFloat()
val calculatedOffset = dragAmount.y - currentItemOffset - dragAndDropState.dragOffsetInItem
```
Використовується **поточне** значення offset з `LazyListItemInfo`, яке **динамічно змінюється** при скролі.

## Чому це працює

1. **LazyColumn динамічно змінює offset елементів** при скролі (навіть без авто-скролу, просто через recomposition)
2. **Ваша формула була правильною**, але використовувала застарілі дані
3. Тепер кожного разу, коли `calculateDnDVisualState` викликається, ми **читаємо свіжий offset**

## Тестування

Після застосування:

1. **Логи будуть плавними**:
```
fingerY=570, currentItemOffset=313, dragOffsetInItem=-189, → translationY=446
fingerY=571, currentItemOffset=314, dragOffsetInItem=-189, → translationY=446  // ✅ Стабільно!
```

2. **Елемент візуально рухатиметься** за пальцем без стрибків

## Якщо все ще не працює

Якщо після цього виправлення елемент все ще не рухається візуально, **додайте лог у `DraggableItem.kt`**:

```kotlin
@Composable
fun DraggableItem(
    isDragging: Boolean,
    yOffset: Float,
    // ...
) {
    // ✅ Додайте цей лог ПЕРЕД graphicsLayer
    if (isDragging) {
        Log.d("DraggableItem", "Rendering: yOffset=$yOffset, isDragging=$isDragging")
    }
    
    val itemModifier = modifier
        .animateContentSize()
        .zIndex(if (isDragging) 1f else 0f)
        .graphicsLayer {
            translationY = yOffset  // Чи доходить сюди правильне значення?
            // ...
        }
```

Це покаже, чи **доходить** значення до рівня промальовки.

***

package com.romankozak.forwardappmobile.ui.dnd

import androidx.compose.ui.geometry.Offset
import androidx.compose.foundation.lazy.LazyListItemInfo
import android.util.Log

private const val TAG = "DnDVisualsManager"

class DnDVisualsManager(
    private val lazyListInfoProvider: LazyListInfoProvider,
    private val dragDropManager: DragDropManager
) {

    fun calculateDnDVisualState(
        dragAndDropState: DragAndDropState
    ): DnDVisualState {
        val draggedItemIndex = dragAndDropState.draggedItemIndex
        val dragAmount = dragAndDropState.dragAmount
        val dragInProgress = dragAndDropState.dragInProgress

        if (!dragInProgress || draggedItemIndex == null) {
            return DnDVisualState(isDragging = false)
        }

        // Calculate the new target index
        val newTargetIndex = lazyListInfoProvider.lazyListItemInfo
            .firstOrNull { item ->
                val itemTop = item.offset
                val itemBottom = item.offset + item.size
                val draggedItemCenter = dragAndDropState.dragAmount.y
                draggedItemCenter > itemTop && draggedItemCenter < itemBottom && item.index != draggedItemIndex
            }?.index

        if (newTargetIndex != dragAndDropState.targetItemIndex) {
            dragDropManager.setTargetItemIndex(newTargetIndex)
        }

        val targetItemIndex = newTargetIndex ?: dragAndDropState.targetItemIndex

        val itemOffsets = mutableMapOf<Int, Float>()
        var draggedItemHeight = 0f

        // ✅ КРИТИЧНО: Отримуємо ПОТОЧНУ позицію елемента
        val draggedItemInfo = lazyListInfoProvider.lazyListItemInfo.firstOrNull { it.index == draggedItemIndex }
        if (draggedItemInfo != null) {
            draggedItemHeight = draggedItemInfo.size.toFloat()
            
            // ✅ ВИПРАВЛЕННЯ: Використовуємо ПОТОЧНИЙ offset, а не збережений
            val currentItemOffset = draggedItemInfo.offset.toFloat()
            val calculatedOffset = dragAmount.y - currentItemOffset - dragAndDropState.dragOffsetInItem
            
            Log.d(TAG, "Dragged Item ($draggedItemIndex) | " +
                "fingerY=${dragAmount.y.toInt()}, " +
                "currentItemOffset=${currentItemOffset.toInt()}, " +
                "dragOffsetInItem=${dragAndDropState.dragOffsetInItem.toInt()}, " +
                "→ translationY=${calculatedOffset.toInt()}"
            )
            
            itemOffsets[draggedItemIndex] = calculatedOffset
        }

        if (targetItemIndex != null && targetItemIndex >= 0) {
            lazyListInfoProvider.lazyListItemInfo.forEach { item ->
                val itemIndex = item.index
                if (itemIndex == draggedItemIndex) {
                    // Вже обробили вище
                } else {
                    val offset = when {
                        draggedItemIndex < itemIndex && itemIndex <= targetItemIndex -> -draggedItemHeight
                        targetItemIndex <= itemIndex && itemIndex < draggedItemIndex -> draggedItemHeight
                        else -> 0f
                    }
                    itemOffsets[itemIndex] = offset
                }
            }
        }

        return DnDVisualState(
            itemOffsets = itemOffsets,
            draggedItemHeight = draggedItemHeight,
            isDragging = dragInProgress
        )
    }
}

***

