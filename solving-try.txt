Проблема полягає в тому, що Room не може напряму зберігати складні типи без TypeConverter. Оскільки спроби додати `reminderStatus` до `Goal` викликають помилки, найкращим рішенням є використання **окремої таблиці** `ReminderInfo`, яка вже існує у вашій базі даних.

Ось комплексне рішення:

## 1. Оновіть `ReminderInfo` для зберігання статусу

У файлі `DatabaseModel.kt` ви вже маєте:

```kotlin
@Entity(tableName = "reminder_info")
data class ReminderInfo(
    @PrimaryKey val goalId: String,
    @ColumnInfo(name = "reminder_status", defaultValue = "'ACTIVE'") val reminderStatus: String = "ACTIVE",
    @ColumnInfo(name = "snooze_time") val snoozeTime: Long? = null,
)
```

Це чудово підходить для вашої задачі. Додайте enum для статусів:

```kotlin
enum class ReminderStatus {
    ACTIVE,      // Активне нагадування
    SNOOZED,     // Відкладене
    COMPLETED,   // Виконане
    DISMISSED    // Пропущене
}
```

## 2. Оновіть DAO для роботи з `ReminderInfo`

Переконайтеся, що у `ReminderInfoDao` є необхідні методи:

```kotlin
@Dao
interface ReminderInfoDao {
    @Query("SELECT * FROM reminder_info WHERE goalId = :goalId")
    suspend fun getReminderInfo(goalId: String): ReminderInfo?
    
    @Query("SELECT * FROM reminder_info WHERE goalId = :goalId")
    fun getReminderInfoFlow(goalId: String): Flow<ReminderInfo?>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(reminderInfo: ReminderInfo)
    
    @Query("DELETE FROM reminder_info WHERE goalId = :goalId")
    suspend fun deleteByGoalId(goalId: String)
    
    @Query("DELETE FROM reminder_info WHERE reminderStatus IN ('COMPLETED', 'DISMISSED')")
    suspend fun clearCompletedAndDismissed()
}
```

## 3. Оновіть `RemindersViewModel`## 4. Додайте відсутній метод до `ReminderInfoDao`

```kotlin
@Query("SELECT * FROM reminder_info")
fun getAllReminderInfoFlow(): Flow<List<ReminderInfo>>
```

## 5. Оновіть `RemindersScreen`## 6. Оновіть `ReminderBroadcastReceiver`

Щоб зберігати статус при взаємодії користувача зі сповіщенням:

```kotlin
private fun handleCompleteAction(context: Context, intent: Intent) {
    val goalId = intent.getStringExtra(EXTRA_GOAL_ID) ?: return
    Log.d(tag, "Goal completed via notification: $goalId")

    // Зберігаємо статус
    CoroutineScope(Dispatchers.IO).launch {
        val reminderInfoDao = /* отримайте DAO через Hilt або ServiceLocator */
        reminderInfoDao.insertOrUpdate(
            ReminderInfo(
                goalId = goalId,
                reminderStatus = "COMPLETED",
                snoozeTime = null
            )
        )
    }

    val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    nm.cancel(getNotificationId(goalId))

    if (ReminderLockScreenActivity.isActive) {
        val closeIntent = Intent(context, ReminderLockScreenActivity::class.java).apply {
            putExtra("ACTION", "CLOSE")
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        try {
            context.startActivity(closeIntent)
        } catch (e: Exception) {
            Log.w(tag, "Could not close lock screen activity", e)
        }
    }
}

private fun handleSnoozeAction(context: Context, intent: Intent) {
    val goalId = intent.getStringExtra(EXTRA_GOAL_ID) ?: return
    Log.d(tag, "Goal snoozed via notification: $goalId")

    val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    nm.cancel(getNotificationId(goalId))

    CoroutineScope(Dispatchers.IO).launch {
        val snoozeTime = System.currentTimeMillis() + (15 * 60 * 1000) // 15 хвилин
        val reminderInfoDao = /* отримайте DAO */
        reminderInfoDao.insertOrUpdate(
            ReminderInfo(
                goalId = goalId,
                reminderStatus = "SNOOZED",
                snoozeTime = snoozeTime
            )
        )
        alarmScheduler.snooze(goalId)
    }

    if (ReminderLockScreenActivity.isActive) {
        val closeIntent = Intent(context, ReminderLockScreenActivity::class.java).apply {
            putExtra("ACTION", "CLOSE")
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        try {
            context.startActivity(closeIntent)
        } catch (e: Exception) {
            Log.w(tag, "Could not close lock screen activity", e)
        }
    }
}

private fun handleDismissAction(context: Context, intent: Intent) {
    val goalId = intent.getStringExtra(EXTRA_GOAL_ID) ?: return
    Log.d(tag, "Goal dismissed via notification: $goalId")

    CoroutineScope(Dispatchers.IO).launch {
        val reminderInfoDao = /* отримайте DAO */
        reminderInfoDao.insertOrUpdate(
            ReminderInfo(
                goalId = goalId,
                reminderStatus = "DISMISSED",
                snoozeTime = null
            )
        )
    }

    val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    nm.cancel(getNotificationId(goalId))

    if (ReminderLockScreenActivity.isActive) {
        val closeIntent = Intent(context, ReminderLockScreenActivity::class.java).apply {
            putExtra("ACTION", "CLOSE")
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        try {
            context.startActivity(closeIntent)
        } catch (e: Exception) {
            Log.w(tag, "Could not close lock screen activity", e)
        }
    }
}
```

## Підсумок

Це рішення:
1. **Використовує окрему таблицю** `ReminderInfo` замість додавання поля до `Goal` (уникає помилок Room)
2. **Відображає статус** нагадувань у реальному часі через Flow
3. **Додає кнопку "Очистити"** для видалення виконаних/пропущених нагадувань
4. **Зберігає статус** при взаємодії зі сповіщеннями
5. **Сортує нагадування** - активні/відкладені вгорі, інші внизу

Переваги цього підходу:
- Чиста архітектура (normalized database)
- Немає конфліктів з Room
- Легко розширюється (можна додати історію нагадувань)
- Reactive updates через Flow

***

package com.romankozak.forwardappmobile.ui.screens.reminders

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.romankozak.forwardappmobile.data.database.models.ListItem
import com.romankozak.forwardappmobile.data.database.models.ListItemContent
import com.romankozak.forwardappmobile.data.database.models.ListItemType
import com.romankozak.forwardappmobile.ui.screens.projectscreen.components.backlogitems.GoalItem
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.UUID

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RemindersScreen(
    navController: NavController,
    viewModel: RemindersViewModel = hiltViewModel()
) {
    val reminders by viewModel.reminders.collectAsState()
    val currentTimeMillis by remember { mutableStateOf(System.currentTimeMillis()) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Нагадування") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Назад")
                    }
                },
                actions = {
                    TextButton(onClick = { viewModel.clearCompletedReminders() }) {
                        Icon(
                            imageVector = Icons.Default.Delete,
                            contentDescription = "Очистити",
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text("Очистити", color = MaterialTheme.colorScheme.primary)
                    }
                }
            )
        }
    ) { paddingValues ->
        if (reminders.isEmpty()) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = "Немає активних нагадувань",
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        } else {
            LazyColumn(modifier = Modifier.padding(paddingValues)) {
                items(reminders) { goalWithStatus ->
                    val goal = goalWithStatus.goal
                    val reminderInfo = goalWithStatus.reminderInfo
                    val listItem = ListItem(
                        id = UUID.randomUUID().toString(),
                        projectId = "",
                        itemType = ListItemType.GOAL,
                        entityId = goal.id,
                        order = 0
                    )

                    Box {
                        GoalItem(
                            goalContent = ListItemContent.GoalItem(goal, listItem),
                            onCheckedChange = { _ -> },
                            onClick = { },
                            onLongClick = { },
                            isSelected = false,
                            currentTimeMillis = currentTimeMillis
                        )

                        // Відображення статусу
                        reminderInfo?.let { info ->
                            val statusText = when (info.reminderStatus) {
                                "SNOOZED" -> {
                                    val snoozeTime = info.snoozeTime ?: 0L
                                    val formatter = SimpleDateFormat("HH:mm", Locale.getDefault())
                                    "⏰ Відкладено до ${formatter.format(Date(snoozeTime))}"
                                }
                                "COMPLETED" -> "✅ Виконано"
                                "DISMISSED" -> "❌ Пропущено"
                                else -> null
                            }

                            statusText?.let { text ->
                                Row(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .align(Alignment.BottomStart)
                                        .background(
                                            when (info.reminderStatus) {
                                                "SNOOZED" -> Color(0xFFFFF3E0)
                                                "COMPLETED" -> Color(0xFFE8F5E9)
                                                "DISMISSED" -> Color(0xFFFFEBEE)
                                                else -> Color.Transparent
                                            }
                                        )
                                        .padding(horizontal = 16.dp, vertical = 8.dp),
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Text(
                                        text = text,
                                        fontSize = 12.sp,
                                        fontWeight = FontWeight.Medium,
                                        color = when (info.reminderStatus) {
                                            "SNOOZED" -> Color(0xFFE65100)
                                            "COMPLETED" -> Color(0xFF2E7D32)
                                            "DISMISSED" -> Color(0xFFC62828)
                                            else -> Color.Gray
                                        }
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

***

package com.romankozak.forwardappmobile.ui.screens.reminders

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.romankozak.forwardappmobile.data.database.models.Goal
import com.romankozak.forwardappmobile.data.database.models.ReminderInfo
import com.romankozak.forwardappmobile.data.repository.ProjectRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

data class GoalWithReminderStatus(
    val goal: Goal,
    val reminderInfo: ReminderInfo?
)

@HiltViewModel
class RemindersViewModel @Inject constructor(
    private val projectRepository: ProjectRepository,
    private val reminderInfoDao: com.romankozak.forwardappmobile.data.dao.ReminderInfoDao
) : ViewModel() {

    val reminders: StateFlow<List<GoalWithReminderStatus>> = projectRepository.getAllGoalsFlow()
        .combine(reminderInfoDao.getAllReminderInfoFlow()) { goals, reminderInfoList ->
            val reminderInfoMap = reminderInfoList.associateBy { it.goalId }
            goals
                .filter { it.reminderTime != null }
                .map { goal ->
                    GoalWithReminderStatus(
                        goal = goal,
                        reminderInfo = reminderInfoMap[goal.id]
                    )
                }
                .sortedWith(
                    compareByDescending<GoalWithReminderStatus> { 
                        it.reminderInfo?.reminderStatus == "ACTIVE" || it.reminderInfo?.reminderStatus == "SNOOZED"
                    }.thenByDescending { 
                        it.reminderInfo?.snoozeTime ?: it.goal.reminderTime ?: 0L 
                    }
                )
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

    fun clearCompletedReminders() {
        viewModelScope.launch {
            reminderInfoDao.clearCompletedAndDismissed()
        }
    }
}