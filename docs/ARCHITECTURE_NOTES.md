# Архітектурні нотатки

## Навіщо цей документ
Під час роботи над головним екраном кілька разів виникала потреба згадати, чому конкретні флоу влаштовані саме так. Цей файл — стартова точка для коротких нотаток про архітектурні рішення, щоб вони не губилися між задачами.

- Пишемо українською, короткими блоками.
- Для великих тем створюємо окремий файл у `docs/` і додаємо сюди посилання.
- Уникаємо дублювання інформації з код-коментарів: сюди виносимо лише те, що допоможе зрозуміти _чому_ ми зробили саме так.

## Головний екран: потоки готовності `PlanningUseCase`

- `PlanningUseCase` позначено `@ViewModelScoped`, щоб усі залежні use-case-и працювали з одним інстансом. Це критично: якщо створити його повторно, `filterStateFlow` залишиться у стані `isReady=false`, і UI не отримає ієрархію.
- Побудова дерева винесена в `HierarchyStateBuilder`. Він:
  - кешує останній не порожній `flatList` для fallback'у після переходу у `ready` з пустим списком;
  - тримає останню побудовану `ListHierarchyData`, щоб UI не блимав, доки `PlanningUseCase` ще не готовий;
  - повторно використовує існуючі `HierarchyDebug`-логи, тож діагностика залишилась незмінною.
- Обов'язкові тести: `PlanningUseCaseTest` (існуючий) і `HierarchyStateBuilderTest` (перевіряє нормалізацію та fallback).

## Керування станом у `BacklogView`

Для складних екранів, як `BacklogView`, було розглянуто використання MVI-бібліотеки (наприклад, Orbit MVI), щоб зробити потік даних більш передбачуваним. Наразі рішення не прийнято, але це може бути гарним напрямком для майбутнього рефакторингу.

## Як додавати нові нотатки

1. Якщо тема невелика — додаємо новий підрозділ у цьому файлі.
2. Якщо потрібен розлогий опис/діаграма, створюємо новий файл `docs/<назва>.md`, а тут залишаємо короткий bullet з посиланням.
3. Для рішень, що впливають на командну роботу (наприклад, вимоги до scope), варто продублювати коротку згадку у `MASTER_PLAN.md`, щоб їх не забули перед великими змінами.
