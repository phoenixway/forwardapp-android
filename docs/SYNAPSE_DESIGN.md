## Фіча: «ForwardApp Synapse» — безшовна синхронізація та екосистема даних

### 1. Продуктове бачення

*   **Що досягає в ідеалі:** Synapse перетворює ForwardApp з ізольованого інструменту на єдину, миттєво синхронізовану екосистему на всіх пристроях користувача (Android, Desktop, Web). Дані з'являються там, де вони потрібні, ще до того, як користувач встиг про це подумати.
*   **Кілер-ідея: «Zero-Friction Sync»**. Синхронізація не є дією, яку користувач ініціює. Вона просто відбувається — непомітно, швидко, надійно, у фоновому режимі. Єдиний раз, коли користувач думає про синхронізацію — це коли бачить її статус "Оновлено щойно" і відчуває впевненість.
*   **Який біль вирішує:**
    *   Усуває страх втрати даних.
    *   Знімає когнітивне навантаження "А де мої останні зміни?".
    *   Дозволяє працювати над одним і тим же проектом з різних пристроїв без конфліктів та ручного перенесення.
    *   Відкриває шлях до спільної роботи у майбутньому.

### 2. Креслення користувацького досвіду (UX Blueprint)

*   **Основні сценарії:**
    1.  **Перший запуск на новому пристрої:** Користувач логіниться, і через 5-15 секунд його повна база даних вже доступна.
    2.  **Робота офлайн:** Користувач вносить десятки змін в літаку. Після приземлення та підключення до мережі, всі зміни автоматично відправляються на сервер і завантажуються на інші пристрої.
    3.  **Одночасна робота (конфлікт):** Користувач змінив назву завдання на телефоні, а його опис — на десктопі. Система автоматично змержить зміни без втрати даних.
    4.  **Імпорт/Експорт:** Користувач хоче зробити локальний бекап у JSON або поділитися проектом з іншим користувачем (у майбутньому).

*   **UI Поверхні:**
    *   **Екран налаштувань -> Synapse:**
        *   Статус синхронізації (іконка + текст: `Синхронізовано`, `Синхронізація...`, `Помилка`, `Офлайн`).
        *   Остання вдала синхронізація (`щойно`, `5 хвилин тому`).
        *   Кількість локальних змін, що чекають на відправку.
        *   Кнопка "Синхронізувати примусово".
        *   Розділ "Керування даними":
            *   "Експортувати все (JSON)" — для бекапу.
            *   "Імпортувати з файлу" — для відновлення.
    *   **Головний екран (невеликий індикатор):** Тонка смужка або іконка в статус-барі, яка анімується під час синхронізації.

*   **Ключові взаємодії:**
    *   **Анімація:** Під час синхронізації іконка плавно "дихає" або обертається. При завершенні — коротка, приємна анімація (напр., галочка).
    *   **Жести:** В налаштуваннях `pull-to-refresh` для примусової синхронізації.
    *   **Сповіщення:** Тільки у випадку критичної помилки (напр., конфлікт, який неможливо вирішити автоматично).

*   **«Ага-моменти»:**
    *   Користувач відкриває додаток на ноутбуці і бачить завдання, яке щойно додав з телефону. Без жодних дій.
    *   Після тижня офлайн, додаток за хвилину синхронізує гігантський обсяг змін, показуючи прогрес.

### 3. Технічна архітектура (KMP)

Це серце системи. Ми будемо використовувати гібридний підхід: **State-Based** для першої синхронізації та **Operation-Based (CRDT-like)** для подальших змін.

*   **Модель даних та SQLDelight:**
    *   **Вимога:** У кожної сутності (`projects`, `tasks`, `notes` і т.д.) має бути 4 нових стовпці:
        *   `synced_at: TEXT?` (ISO 8601 UTC) — час останньої синхронізації цього рядка з сервером.
        *   `updated_at: TEXT` — локальний час останньої зміни (оновлюється тригером).
        *   `is_deleted: INTEGER AS Boolean DEFAULT 0` — м'яке видалення.
        *   `version: INTEGER DEFAULT 0` — лічильник версій для вирішення конфліктів (LWW — Last Write Wins).

    ```sql
    -- Example for 'tasks' table
    CREATE TABLE tasks (
        id TEXT NOT NULL PRIMARY KEY,
        project_id TEXT,
        title TEXT NOT NULL,
        description TEXT,
        created_at TEXT NOT NULL,
        -- Synapse columns
        updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
        synced_at TEXT,
        is_deleted INTEGER AS Boolean NOT NULL DEFAULT 0,
        version INTEGER NOT NULL DEFAULT 0,
        FOREIGN KEY(project_id) REFERENCES projects(id)
    );

    -- Trigger to auto-update 'updated_at' and 'version' on any change
    CREATE TRIGGER tasks_updated_at
    AFTER UPDATE OF title, description, project_id ON tasks
    FOR EACH ROW
    BEGIN
        UPDATE tasks
        SET
            updated_at = strftime('%Y-%m-%dT%H:%M:%fZ', 'now'),
            version = OLD.version + 1
        WHERE id = OLD.id;
    END;
    ```

*   **Repository API (`SyncRepository`):**
    *   Це буде центральний оркестратор.
    *   `suspend fun sync(force: Boolean = false): SyncResult`
    *   `suspend fun getUnsyncedChanges(): List<BaseEntity>` — збирає всі об'єкти, де `updated_at > synced_at` або `synced_at IS NULL`.
    *   `suspend fun applyServerChanges(changes: List<BaseEntity>)` — приймає дані з сервера і вставляє/оновлює їх у локальну БД.
    *   `suspend fun exportAllData(): JsonString`
    *   `suspend fun importData(data: JsonString): ImportResult`

*   **Доменні Use-Cases:**
    *   `SyncUseCase(syncRepository, workManager)`: Головний use-case. Запускає `syncRepository.sync()`. Обгортається в `WorkManager` на Android для фонового виконання.
    *   `GetSyncStatusUseCase(syncRepository)`: Flow<SyncStatus> для UI.
    *   `ExportDataUseCase(syncRepository)`
    *   `ImportDataUseCase(syncRepository)`

*   **KMP ViewModels (`SyncSettingsViewModel`):**
    *   `val state: StateFlow<SyncSettingsState>`
    *   `fun onForceSyncClicked()`
    *   `fun onExportClicked()`
    *   `fun onImportFileSelected(uri)`
    *   Збирає `GetSyncStatusUseCase` і оновлює `state`.

*   **Android UI (Compose):**
    *   `SyncSettingsScreen(state, onEvent)`
    *   `SyncStatusIndicator(status)` — той самий індикатор для статус-бару.

*   **DI (Kotlin-Inject):**
    ```kotlin
    @Provides
    fun provideSyncRepository(database: AppDatabase, apiClient: ApiClient): SyncRepository {
        return SyncRepositoryImpl(database.syncQueries, apiClient)
    }

    @Provides
    fun provideSyncUseCase(repository: SyncRepository, workManager: WorkManager): SyncUseCase {
        return SyncUseCase(repository, workManager)
    }
    ```

### 4. Системна інтеграція

*   **Підключення до модулів:** `SyncRepository` буде залежати від `DAO` (або `Queries` в SQLDelight) кожного існуючого модуля (`TasksRepository`, `ProjectsRepository` і т.д.), щоб отримати "брудні" (несинхронізовані) дані.
*   **Навігація:** З головного меню -> Налаштування -> "Synapse".
*   **Вплив на систему:** Це фундаментальна зміна. Кожна операція `INSERT`, `UPDATE`, `DELETE` у додатку має тепер використовувати м'яке видалення (`is_deleted = 1`) і оновлювати `updated_at`. Це найкраще реалізувати на рівні репозиторіїв.

### 5. Продуктивність та надійність

*   **Кешування:** Локальна база даних (SQLDelight) є єдиним джерелом правди для UI. Сервер — це лише "дзеркало".
*   **Офлайн:** Система розроблена для офлайну за замовчуванням. Всі зміни накопичуються локально.
*   **Механізм синхронізації (детальніше):**
    1.  Клієнт запитує у сервера: "Ось мої зміни з моменту `lastSyncTimestamp`" (надсилає `List<BaseEntity>`).
    2.  Сервер приймає зміни. Якщо є конфлікт (та ж сутність була змінена на іншому клієнті), він застосовує стратегію **LWW (Last Write Wins)**, порівнюючи `version` або `updated_at`. Переможець — той, у кого час/версія більша.
    3.  Сервер відповідає клієнту: "Ось зміни, які відбулися на інших пристроях з твого `lastSyncTimestamp`".
    4.  Клієнт застосовує ці зміни до своєї локальної БД, перезаписуючи свої старіші версії, якщо такі є.
    5.  Оновлює `synced_at` для всіх оброблених сутностей.

### 6. Розширений бонус

#### 3 Радикально різні варіації дизайну:

1.  **Мінімалістичний (поточний план):** Фокус на "zero-friction". Мінімум UI. Максимум автоматизації. Ідеально для 90% користувачів.
2.  **Pro/Power-User:** Додатковий екран "Центр синхронізації".
    *   **Журнал синхронізацій:** Детальний лог кожної сесії.
    *   **Вирішення конфліктів вручну:** UI, де показується "твоя версія" і "серверна версія" з можливістю вибрати, яку залишити, або об'єднати поля.
    *   **Вибір гілок даних:** Можливість створювати "бекап-гілки" на сервері (напр., "до рефакторингу проекту Х").
3.  **AI-driven (майбутнє):**
    *   **"Розумна" синхронізація:** Додаток аналізує контекст (календар, місцезнаходження) і проактивно синхронізує дані, які, ймовірно, знадобляться. (Напр., перед зустріччю підтягує всі нотатки по темі).
    *   **Автоматичне виправлення даних:** AI помічає, що ви створили два схожих завдання на різних пристроях і пропонує їх об'єднати.
    *   **Аналіз змін:** "Схоже, ви видалили важливий проект. Ви впевнені? Ось його короткий зміст".

#### Майбутнє розширення:

*   **Спільна робота:** Поточна архітектура є фундаментом для multi-user колаборації. Потрібно додати таблицю `permissions`.
*   **Веб-клієнт:** Наявність API дозволить швидко створити веб-версію.
*   **Інтеграція з третіми сервісами (Zapier, IFTTT):** API можна відкрити для автоматизації.

#### Ризики та їх пом'якшення:

*   **Ризик:** Конфлікти злиття, що призводять до втрати даних.
    *   **Пом'якшення:** Ретельне тестування LWW. Для критичних даних (напр., текст нотатки) можна використовувати диференційовані патчі (diff-patch) замість повної заміни. На рівні Pro — ручне вирішення.
*   **Ризик:** Навантаження на батарею через постійну фонову синхронізацію.
    *   **Пом'якшення:** Використовувати `WorkManager` з обмеженнями (тільки при підключенні до Wi-Fi, під час зарядки). Використовувати `debounce` для групування частих змін в один запит.
*   **Ризик:** Складність серверної частини.
    *   **Пом'якшення:** Використовувати готові рішення як Firebase Firestore (якщо можливо) або розробляти бекенд на Ktor/PostgreSQL з чіткою логікою.

#### План реалізації:

1.  **MVP (1-2 тижні):**
    *   Реалізувати стовпці `updated_at`, `is_deleted`, `version`, `synced_at` та тригери в БД.
    *   Створити `SyncRepository` з функціями `getUnsyncedChanges` та `applyServerChanges`.
    *   Реалізувати експорт/імпорт в JSON. Це дозволить користувачам переносити дані вручну, поки немає бекенду.
    *   UI для експорту/імпорту.

2.  **Beta (наступні 3-4 тижні):**
    *   Розробка простого бекенд-API (Ktor) з базою даних (Postgres).
    *   Реалізація логіки синхронізації на клієнті та сервері (LWW).
    *   Внутрішнє тестування на двох пристроях.

3.  **Production (після бети):**
    *   Додати фонову синхронізацію через `WorkManager`.
    *   Додати UI статусу синхронізації.
    *   Реліз для користувачів.
    *   Збір фідбеку, моніторинг помилок.